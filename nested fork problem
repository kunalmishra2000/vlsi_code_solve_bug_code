module top;

    initial begin
                 $display( "D" );

        fork
            fork
                #4 $display( $time, "A" );
                #0 $display( $time, "B" );
                $display( $time, "C" );
            join_none
        join_any
        $display( "E" );
    end

endmodule

Yes ðŸ‘ â€” **your understanding is now correct**.
Let me restate it cleanly and precisely in **SystemVerilog terms**, and then Iâ€™ll tighten one small wording detail.

---

## What you are thinking (correct idea)

> In `fork â€¦ join_any`, we have two threads:
>
> 1. the **inner `forkâ€¦join_none` thread**
> 2. the **`$display("D")` thread**
>
> During simulation, **the `forkâ€¦join_none` thread finishes immediately**, so the outer `join_any` is satisfied.
>
> That is why **the parent comes out of the fork and prints `E` before `D` executes**.

âœ… **This is exactly right.**

---

## One small wording correction (important)

You said:

> â€œfirst hit fork join_none thread for it's exist out of forkâ€

More precise wording:

> **The `forkâ€¦join_none` thread *completes immediately***
> (not because its child threads finish, but because `join_none` does not wait).

---

## Exact technical sequence (short & strict)

1. Outer `fork` starts **two concurrent threads**

   * **T1:** inner `fork â€¦ join_none`
   * **T2:** `$display("D")`

2. **T1 executes**

   * Starts inner forked processes
   * Hits `join_none`
   * **T1 finishes immediately**

3. Outer `join_any` condition is met

   * At least **one thread (T1)** is finished

4. Parent continues and executes

   ```sv
   $display("E");
   ```

5. **T2 (`D`) is still alive**

   * It executes later

---

## Mental model you should keep ðŸ”‘

> **`join_none` = â€œfire and forgetâ€**
> **`join_any` = â€œreturn on first finisherâ€**

So when you nest them:

```
join_none  â†’ finishes instantly
join_any   â†’ releases instantly
```

---

## One-line takeaway (exam / interview ready)

> In nested forks, a `join_none` block can terminate immediately, causing an enclosing `join_any` to release **before other forked statements execute**, which is why `E` can print before `D`.

---

Youâ€™ve got it now ðŸ’¯
If you want next, I can:

* Draw a **scheduler timeline**
* Show how to **force deterministic order**
* Show **real UVM race bug caused by this**

Just tell me.
